<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HFSS PostGIS MVT Test</title>
    <!-- Use multiple CDN sources for reliability -->
    <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/maplibre-gl@2.4.0/dist/maplibre-gl.css"
      rel="stylesheet"
    />
    <!-- Fallback option -->
    <script>
      if (typeof maplibregl === 'undefined') {
        document.write(
          '<script src="https://unpkg.com/maplibre-gl@3.0.0/dist/maplibre-gl.js"><\/script>'
        );
        document.write(
          '<link href="https://unpkg.com/maplibre-gl@3.0.0/dist/maplibre-gl.css" rel="stylesheet" />'
        );
      }
    </script>
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }
      .control-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        background: white;
        padding: 10px;
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        z-index: 1;
        max-width: 300px;
      }
      label {
        display: block;
        margin: 5px 0;
      }
      input,
      select {
        width: 100%;
        margin-bottom: 10px;
        padding: 5px;
      }
      button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        width: 100%;
      }
      .status {
        margin-top: 10px;
        padding: 8px;
        border-radius: 4px;
        display: none;
      }
      .status.success {
        background: #dff0d8;
        color: #3c763d;
        display: block;
      }
      .status.error {
        background: #f2dede;
        color: #a94442;
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <div class="control-panel">
      <h3>HFSS Track MVT Tester</h3>

      <label for="flight-uuid">Flight UUID:</label>
      <input
        type="text"
        id="flight-uuid"
        placeholder="e.g. e3077e36-bc4c-4373-bada-72b8cb183a5e"
      />

      <label for="source">Data Source:</label>
      <select id="source">
        <option value="live">live</option>
        <option value="upload">upload</option>
      </select>

      <label for="token">JWT Token:</label>
      <input type="text" id="token" placeholder="Bearer token" />

      <label for="api-url">API URL:</label>
      <input
        type="text"
        id="api-url"
        value="https://api.hikeandfly.app/tracking"
      />

      <button id="load-track">Load Track</button>

      <div id="status-message" class="status"></div>
    </div>

    <script>
      // Get the maplibre object, which might be exposed as maplibre or maplibregl
      const maplibreLib = window.maplibre || window.maplibregl;

      if (!maplibreLib) {
        document.getElementById('status-message').textContent =
          'Could not load MapLibre GL JS library. Please check your internet connection and try again.';
        document.getElementById('status-message').className = 'status error';
        throw new Error('MapLibre GL JS library not loaded');
      }

      // Initialize the map
      const map = new maplibreLib.Map({
        container: 'map',
        style: 'https://demotiles.maplibre.org/style.json',
        center: [11.259, 43.773], // Florence, Italy as default center
        zoom: 10,
      });

      // Add navigation controls
      map.addControl(new maplibreLib.NavigationControl());

      let trackSource = null;

      document
        .getElementById('load-track')
        .addEventListener('click', function () {
          const flightUuid = document.getElementById('flight-uuid').value;
          const source = document.getElementById('source').value;
          const token = document.getElementById('token').value;
          const apiUrl = document.getElementById('api-url').value;

          if (!flightUuid || !token) {
            showStatus('Please provide both flight UUID and token', 'error');
            return;
          }

          // Remove existing track layer and source if they exist
          if (map.getLayer('track-points')) {
            map.removeLayer('track-points');
          }

          if (map.getSource('track')) {
            map.removeSource('track');
          }

          // Define the vector tile source URL
          const mvtUrl = `${apiUrl}/postgis-mvt/{z}/{x}/{y}?flight_uuid=${flightUuid}&source=${source}&token=${token}`;

          // Add the vector tile source
          map.addSource('track', {
            type: 'vector',
            tiles: [mvtUrl],
            minzoom: 0,
            maxzoom: 22,
          });

          // Add the track points layer
          map.addLayer({
            id: 'track-points',
            type: 'circle',
            source: 'track',
            'source-layer': 'track_points',
            paint: {
              'circle-radius': [
                'interpolate',
                ['linear'],
                ['zoom'],
                9,
                1.5,
                13,
                3,
                16,
                5,
              ],
              'circle-color': [
                'interpolate',
                ['linear'],
                ['get', 'elevation'],
                0,
                '#00ff00', // Green at 0m
                1000,
                '#ffff00', // Yellow at 1000m
                3000,
                '#ff0000', // Red at 3000m
              ],
              'circle-opacity': 0.8,
              'circle-stroke-width': 1,
              'circle-stroke-color': '#fff',
            },
          });

          // Also add a line layer connecting the points
          map.addLayer({
            id: 'track-line',
            type: 'line',
            source: 'track',
            'source-layer': 'track_lines', // Using the new track_lines layer from MVT
            paint: {
              'line-color': '#ff0000', // Bright red
              'line-width': [
                'interpolate',
                ['linear'],
                ['zoom'],
                8,
                3, // Increased base width
                12,
                4, // Increased medium zoom width
                16,
                6, // Increased high zoom width
              ],
              'line-opacity': 1.0, // Full opacity
            },
          });

          // Add debug info to help troubleshoot layer issues
          map.on('sourcedata', function (e) {
            if (e.sourceId === 'track' && map.isSourceLoaded('track')) {
              // Check if we have the layers in the source
              const layers = map.getStyle().layers;
              const pointLayerExists = layers.some(
                (layer) => layer.id === 'track-points'
              );
              const lineLayerExists = layers.some(
                (layer) => layer.id === 'track-line'
              );

              if (pointLayerExists && lineLayerExists) {
                console.log('Both layers configured correctly');
              } else {
                console.warn(
                  'Missing layers:',
                  !pointLayerExists ? 'track-points' : '',
                  !lineLayerExists ? 'track-line' : ''
                );
              }
            }
          });

          // Attempt to fit bounds after the source is loaded
          map.once('sourcedata', function (e) {
            if (e.sourceId === 'track' && map.isSourceLoaded('track')) {
              // We need to manually request a tile to check if there are features
              fetchTile(flightUuid, source, token, apiUrl, 0, 0, 0).then(
                (tileInfo) => {
                  if (tileInfo.hasFeatures) {
                    // Check which layers were found
                    let statusMsg = 'Track loaded successfully! ';
                    if (tileInfo.hasPoints && tileInfo.hasLines) {
                      statusMsg += 'Both points and lines visible.';
                    } else if (tileInfo.hasPoints) {
                      statusMsg +=
                        'Only points visible. Line layer may be missing.';
                    } else if (tileInfo.hasLines) {
                      statusMsg +=
                        'Only lines visible. Point layer may be missing.';
                    }

                    showStatus(statusMsg, 'success');

                    // Use the track line endpoint to get the bounds
                    fetch(
                      `${apiUrl}/track-line/${flightUuid}?source=${source}`,
                      {
                        headers: {
                          Authorization: `Bearer ${token}`,
                        },
                      }
                    )
                      .then((response) => response.json())
                      .then((data) => {
                        if (
                          data &&
                          data.geometry &&
                          data.geometry.coordinates &&
                          data.geometry.coordinates.length > 0
                        ) {
                          // Create a bounding box from the coordinates
                          const bounds = new maplibreLib.LngLatBounds();
                          data.geometry.coordinates.forEach((coord) => {
                            bounds.extend([coord[0], coord[1]]);
                          });
                          map.fitBounds(bounds, { padding: 50 });
                        }
                      })
                      .catch((error) => {
                        console.error('Error fetching track line:', error);
                        showStatus(
                          'Error fetching track bounds: ' + error.message,
                          'error'
                        );
                      });
                  } else {
                    showStatus(
                      'No track data found for this flight. Please verify the flight UUID and token.',
                      'error'
                    );
                  }
                }
              );
            }
          });
        });

      // Function to fetch a tile and check if it has features
      async function fetchTile(flightUuid, source, token, apiUrl, z, x, y) {
        try {
          const response = await fetch(
            `${apiUrl}/postgis-mvt/${z}/${x}/${y}?flight_uuid=${flightUuid}&source=${source}&token=${token}`
          );

          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }

          // We can't easily parse the MVT binary format in the browser,
          // but we can check if the tile is not empty (has content)
          const buffer = await response.arrayBuffer();

          // Make a separate request to check layers
          // We'll use the actual track-line endpoint to check if lines should exist
          let hasLines = false;
          try {
            const lineResponse = await fetch(
              `${apiUrl}/track-line/${flightUuid}?source=${source}`,
              {
                headers: {
                  Authorization: `Bearer ${token}`,
                },
              }
            );
            if (lineResponse.ok) {
              const data = await lineResponse.json();
              if (
                data &&
                data.geometry &&
                data.geometry.coordinates &&
                data.geometry.coordinates.length > 1
              ) {
                hasLines = true;
              }
            }
          } catch (lineError) {
            console.warn('Error checking lines:', lineError);
          }

          return {
            hasFeatures: buffer.byteLength > 0,
            hasPoints: buffer.byteLength > 0, // Assumes there are at least points
            hasLines: hasLines, // Based on our separate check
            byteLength: buffer.byteLength,
          };
        } catch (error) {
          console.error('Error fetching tile:', error);
          showStatus(`Error: ${error.message}`, 'error');
          return {
            hasFeatures: false,
            hasPoints: false,
            hasLines: false,
            error: error.message,
          };
        }
      }

      function showStatus(message, type) {
        const statusEl = document.getElementById('status-message');
        statusEl.textContent = message;
        statusEl.className = 'status ' + type;
      }
    </script>
  </body>
</html>
